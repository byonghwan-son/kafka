# 4장. 상태가 있는 처리

상태가 없는 변환은 앞에서 봤던 이벤트를 기억하지 않아도 되므로 이해하기 쉽고 사용도 쉽다. 상태가 없는 연산자는 모든 이벤트를 불변의 사실로 간주하고 다른 이벤트와 독립적으로 처리한다.

상태가 있는 카프카 스트림즈는 소비 중인 이벤트의 정보를 캡쳐하고 기억하는 기능도 제공한다. 캡처한 정보 또는 상태를 이용하면 데이터 조인과 집계등 좀 더 복잡한 스트림 처리 연산이 가능하다.

* 상태가 있는 스트림 처리의 잇점
* 사실과 행동의 차이점
* 카프카 스트림즈에서 사용 가능한 상태가 있는 연산자 종류
* 카프카 스트림즈에서 상태를 캡쳐하고 쿼리하는 방법
* KTable 추상화로 로컬의 파티셔닝되어 있는 상태를 표현하는 방법
* GlobalKTable 추상화로 전역으로 복제되는 상태를 표현하는 방법
* 데이터 조인과 집계를 포함해 상태가 있는 연산을 수행하는 방법
* 상태를 노출할 때 대화형 쿼리를 사용하는 방법

* 테이블이란?  
  한 번에 한 이벤트씩 이벤트 스트림을 재생. 내장되어 있는 키-값 저장소에 각 키의 최신 상태를 저장. 이러한 재생과 저장의 지속적이며 무한히 흐르는 레코드 스트림에서 특정 시점(Point-in-time)의 상태를 표현할 수 있는 스냅숏(snapshot)

* 사실과 행동의 차이
  * 사실 : 이벤트와 동일함. 어떤 일이 벌어진 사실을 표현. 이벤트는 불변.
  * 행동 : 사실들을 축적하면 행동으로 감지가 됨.

## 상태가 있는 연산자 훑어보기

|사례|목적|연산자들|
|-|-|-|
|데이터 조인|서로 다른 스트림 또는 테이블에서 갭쳐한 추가적인 정보 또는 문맥으로 이벤트를 보강한다.|* join(inner join)<br>* leftJoin<br>* outerJoin|
|데이터 집계|지속적으로 업데이트되는 관련 이벤트의 수학적 또는 조합적 변환 계산|* aggregate<br>* count<br>* reduce|
|데이터 윈도잉|시간상 근접성을 갖는 이벤트들을 그룹화|* windowedBy|

* 상태 저장소
  * 영구 저장소
  * 인-메모리 저장소

* 공통 특성
  * 기본 *상태 저장소* 구현들을 위해 가지고 있는 공통 속성
  * 임베딩
    * 태스크 내에 저장소가 포함(embedded)되어 있음.
    * RocksDB를 사용
  * 다중 접근 모드
    * 전용 읽기 래퍼(wrapper)를 제공
  * 내결함성
    * 카프카의 변경 로그 토픽에 상태를 백업
    * 예비 복사본
  * 키-기반
    * 저장소 형태에 따라 내부적인 구조가 다름

## 영구 저장소 vs 인-메모리 저장소

영구 저장소의 상태 위치 디렉터리 : StreamsConfig.STATE_DIR_CONFIG 속성을 사용해서 설정함.  
기본 위치는 /tmp/kafka-streams 이지만 /tmp 는 재부팅이 되면 삭제가 되므로 다른 곳을 설정하는 편이 좋음

가급적 영구 저장소를 이용할 것(인-메모리에서 자동으로 영구 저장소로 저장을 함.)  
다양한 복구 모델이 존재함.

## 튜토리얼 소개 : 비디오 게임 전광판

![토폴로지](../img/2023-11-16%2020%2006%2024.png)

① 세개의 토픽을 가짐  
* store-events 토픽은 게임 점수를 포함. 레코드가 키를 가지고 있지 않으므로 전체 토픽 파티션에 라운드-로빈 방식으로 producing 처리함.
* player 토픽은 플레이어의 프로파일을 포함. 각 레코드는 player ID를 키로 사용.
* products 토픽은 여러 비디오 게임의 상품 정보를 포함. 각 레코드는 상품 ID를 키로 사용.

② score-events와 players의 상세 정보로 보강  
③ ②번의 결과에 상세한 상품정보로 조인  
④ 데이터 집계전에 그룹핑  
⑤ 각 게임의 상위 최고 점수 세 개를 계산  
⑥ 각 게임의 최고 점수를 외부로 내보내야 한다. RESTful 마이크로서비스로 구축해서 구현.

각 토픽에서 사용될 모델을 정의하고 모델을 Json으로 Serialization과 Deserialization을 할 클래스 작성  
